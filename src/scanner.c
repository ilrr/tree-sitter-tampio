// scanner.c
// Tree-sitter external scanner for Tampio accounting DSL
// Supports block_start/block_end via indentation, colon shorthand, and Unicode
// brackets

#include "tree_sitter/parser.h"
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <wctype.h>

#define INDENT_STACK_SIZE 128
#define BRACKRT_STACK_SIZE 128

// TokenType enum as per Tree-sitter docs
enum TokenType {
    INDENT,
    DEDENT,
    NEWLINE,
    COLON,
    COLON_END,
    WHITESPACE,
    COMMENT
};

// State: bracket stack, indent levels, pending colons/dedents
typedef struct {
    uint8_t indent_stack[INDENT_STACK_SIZE];
    uint8_t bracket_stack[BRACKRT_STACK_SIZE];

    uint8_t bracket_count;
    uint8_t indent_count;
    uint8_t pending_dedents;
    uint8_t colon_count;

} Scanner;

static uint8_t top_indent(Scanner *s) {
    return s->indent_stack[s->indent_count];
}

static void push_indent(Scanner *s, uint8_t indent) {
    s->indent_count++;
    s->indent_stack[s->indent_count] = indent;
}

static uint8_t pop_indent(Scanner *s) {
    if (s->indent_count > 0) {
        s->indent_count--;
    }
    return s->indent_stack[s->indent_count];
}

static uint8_t top_bracket(Scanner *s) {
    return s->bracket_stack[s->bracket_count];
}

static void push_bracket(Scanner *s, uint8_t bracket_id) {
    s->bracket_count++;
    s->bracket_stack[s->bracket_count] = bracket_id;
}

static uint8_t pop_bracket(Scanner *s) {
    if (s->bracket_count > 0) {
        s->bracket_count--;
    }
    return s->bracket_stack[s->bracket_count];
}

// generated by ChatGPT, hope it's correct
uint8_t bracket_id(uint32_t ch) {
    switch (ch) {
    case '(':
        return 2;
    case ')':
        return 3;
    case '[':
        return 4;
    case ']':
        return 5;
    case '{':
        return 6;
    case '}':
        return 7;
    case 0x0F3A:
        return 8;
    case 0x0F3B:
        return 9;
    case 0x0F3C:
        return 10;
    case 0x0F3D:
        return 11;
    case 0x169B:
        return 12;
    case 0x169C:
        return 13;
    case 0x2045:
        return 14;
    case 0x2046:
        return 15;
    case 0x2768:
        return 16;
    case 0x2769:
        return 17;
    case 0x276A:
        return 18;
    case 0x276B:
        return 19;
    case 0x276C:
        return 20;
    case 0x276D:
        return 21;
    case 0x276E:
        return 22;
    case 0x276F:
        return 23;
    case 0x2770:
        return 24;
    case 0x2771:
        return 25;
    case 0x2772:
        return 26;
    case 0x2773:
        return 27;
    case 0x2774:
        return 28;
    case 0x2775:
        return 29;
    case 0x27E6:
        return 30;
    case 0x27E7:
        return 31;
    case 0x27E8:
        return 32;
    case 0x27E9:
        return 33;
    case 0x27EA:
        return 34;
    case 0x27EB:
        return 35;
    case 0x2983:
        return 36;
    case 0x2984:
        return 37;
    case 0x2985:
        return 38;
    case 0x2986:
        return 39;
    case 0x2987:
        return 40;
    case 0x2988:
        return 41;
    case 0x2989:
        return 42;
    case 0x298A:
        return 43;
    case 0x298B:
        return 44;
    case 0x298C:
        return 45;
    case 0x298D:
        return 46;
    case 0x298E:
        return 47;
    case 0x298F:
        return 48;
    case 0x2990:
        return 49;
    case 0x2991:
        return 50;
    case 0x2992:
        return 51;
    case 0x2993:
        return 52;
    case 0x2994:
        return 53;
    case 0x2995:
        return 54;
    case 0x2996:
        return 55;
    case 0x2997:
        return 56;
    case 0x2998:
        return 57;
    case 0x29D8:
        return 58;
    case 0x29D9:
        return 59;
    case 0x29DA:
        return 60;
    case 0x29DB:
        return 61;
    case 0x29FC:
        return 62;
    case 0x29FD:
        return 63;
    case 0x2E22:
        return 64;
    case 0x2E23:
        return 65;
    case 0x2E24:
        return 66;
    case 0x2E25:
        return 67;
    case 0x2E26:
        return 68;
    case 0x2E27:
        return 69;
    case 0x2E28:
        return 70;
    case 0x2E29:
        return 71;
    case 0x3008:
        return 72;
    case 0x3009:
        return 73;
    case 0x300A:
        return 74;
    case 0x300B:
        return 75;
    case 0x300C:
        return 76;
    case 0x300D:
        return 77;
    case 0x300E:
        return 78;
    case 0x300F:
        return 79;
    case 0x3010:
        return 80;
    case 0x3011:
        return 81;
    case 0x3014:
        return 82;
    case 0x3015:
        return 83;
    case 0x3016:
        return 84;
    case 0x3017:
        return 85;
    case 0x3018:
        return 86;
    case 0x3019:
        return 87;
    case 0x301A:
        return 88;
    case 0x301B:
        return 89;
    default:
        return 0;
    }
}

// Lifecycle
void *tree_sitter_tampio_external_scanner_create() {
    Scanner *s = calloc(1, sizeof(Scanner));
    // fprintf(stderr, "indent_count=%d, pending_dedents=%d\n---",
    // s->indent_count, s->pending_dedents);
    s->indent_count = 0;
    s->indent_stack[0] = 0;
    s->bracket_count = 0;
    return s;
}
void tree_sitter_tampio_external_scanner_destroy(void *p) { free(p); }
void tree_sitter_tampio_external_scanner_reset(void *p) {
    memset(p, 0, sizeof(Scanner));
}

unsigned tree_sitter_tampio_external_scanner_serialize(void *p, char *buffer) {
  Scanner *scanner = (Scanner *)p;
  unsigned i = 0;

  buffer[i++] = scanner->indent_count;
  memcpy(&buffer[i], scanner->indent_stack, scanner->indent_count);
  i += scanner->indent_count;

  buffer[i++] = scanner->pending_dedents;
  buffer[i++] = scanner->colon_count;

  buffer[i++] = scanner->bracket_count;
  memcpy(&buffer[i], scanner->bracket_stack, scanner->bracket_count);
  i += scanner->bracket_count;

  return i;
}

void tree_sitter_tampio_external_scanner_deserialize(void *p, const char *buffer, unsigned length) {
  Scanner *scanner = (Scanner *)p;
  unsigned i = 0;

  if (length < 3) {
    scanner->indent_count = 0;
    scanner->bracket_count = 0;
    scanner->pending_dedents = 0;
    scanner->colon_count = 0;
    return;
  }

  scanner->indent_count = buffer[i++];
  if (scanner->indent_count > INDENT_STACK_SIZE) scanner->indent_count = 0;
  memcpy(scanner->indent_stack, &buffer[i], scanner->indent_count);
  i += scanner->indent_count;

  scanner->pending_dedents = buffer[i++];
  scanner->colon_count = buffer[i++];

  scanner->bracket_count = buffer[i++];
  if (scanner->bracket_count > BRACKRT_STACK_SIZE) scanner->bracket_count = 0;
  memcpy(scanner->bracket_stack, &buffer[i], scanner->bracket_count);
}


// unsigned tree_sitter_tampio_external_scanner_serialize(void *p, char *buffer) {
//     Scanner *scanner = (Scanner *)p;
//     // fprintf(stderr, "serialize\n");
//     unsigned size = scanner->indent_count + 4;
//     memcpy(buffer, scanner->indent_stack, scanner->indent_count + 1);
//     buffer[scanner->indent_count + 1] = scanner->indent_count;
//     buffer[scanner->indent_count + 2] = scanner->pending_dedents;
//     buffer[scanner->indent_count + 3] = scanner->colon_count;
//     memcpy(buffer + scanner->indent_count + 4, scanner->bracket_stack, scanner->bracket_count+1);
//     buffer[scanner->indent_count + 5 + scanner->bracket_count] = scanner->bracket_count;
//     // fprintf(stderr, "serialize\n");
//     return size;
// }

// void tree_sitter_tampio_external_scanner_deserialize(void *p,
//                                                      const char *buffer,
//                                                      unsigned length) {
//
//     // fprintf(stderr, "deserialize\n");
//     Scanner *scanner = (Scanner *)p;
//     if (length < 3) {
//         scanner->indent_count = 0;
//         scanner->pending_dedents = 0;
//         scanner->colon_count = 0;
//         scanner->bracket_count =0;
//         return;
//     }
//
//     // iIPCbB
//     //
// uint8_t bracket_count = buffer[length-1];
// memcpy(scanner->bracket_stack, buffer - bracket_count - 1, bracket_count+1);
//
//     uint8_t count = buffer[length - bracket_count - 1 - 3];
//     memcpy(scanner->indent_stack, buffer, count + 1);
//     scanner->indent_count = count;
//     scanner->pending_dedents = buffer[length - bracket_count - 1 - 2];
//     scanner->colon_count = buffer[length - bracket_count - 1];
//     // fprintf(stderr, "deserialize\n");
// }

// Main scanning
bool tree_sitter_tampio_external_scanner_scan(void *p, TSLexer *lexer,
                                              const bool *valid_symbols) {
    Scanner *s = (Scanner *)p;

    // fprintf(stderr, "indent_count=%d, pending_dedents=%d\n", s->indent_count,
    // s->pending_dedents); fflush(stderr);

    // fprintf(stderr, "%c", lexer->lookahead);
    if (s->pending_dedents > 1) {
        s->pending_dedents--;
        lexer->result_symbol = DEDENT;
        return true;
    } else if (s->pending_dedents == 1) {
        s->pending_dedents = 0;
        lexer->advance(lexer, false);
        lexer->result_symbol = NEWLINE;
        return true;
    }
    if (lexer->lookahead == '-') {
        lexer->advance(lexer, false);
        if (lexer->lookahead == '-') {
            lexer->advance(lexer, false);
            while (lexer->lookahead != '\n') {
                lexer->advance(lexer, false);
            }
            lexer->result_symbol = COMMENT;
            return true;
        } else {
            return false;
        }
    }
    if (lexer->lookahead == '\n') {
        // fprintf(stderr, "\nN\n");
        // fflush(stderr);
        if (s->colon_count) {
            s->colon_count--;
            lexer->result_symbol = COLON_END;
            return true;
        }
        lexer->mark_end(lexer);
        lexer->advance(lexer, true);
        uint8_t indent = 0;
        // fprintf(stderr, "%d\n", indent);
        // fprintf(stderr, "lookahead: '%c'\n", lexer->lookahead);
        while (lexer->lookahead == ' ' || lexer->lookahead == '\t' ||
               lexer->lookahead == '\n') {
            // fprintf(stderr, "lookahead: '%c'\n", lexer->lookahead);
            if (lexer->lookahead == '\n') {
                indent = 0;
            } else {
                indent++;
            }
            lexer->advance(lexer, false);
        }
        uint8_t top_i = top_indent(s);
        // fprintf(stderr, "%d %d\n", indent, top_i);
        if (indent == top_i) {
            lexer->result_symbol = NEWLINE;
            lexer->mark_end(lexer); // !!!!!!
            return true;
        } else if (indent > top_i) {
            push_indent(s, indent);
            lexer->result_symbol = INDENT;
            return true;
        } else {
            s->pending_dedents = 1;
            while (indent < top_indent(s)) {
                pop_indent(s);
                s->pending_dedents++;
                // fprintf(stderr, "top indent: %d\n", top_indent(s));
            }
            s->pending_dedents--;
            lexer->result_symbol = DEDENT;
            return true;
        }
    }
    if (valid_symbols[COLON] && lexer->lookahead == ':') {
        lexer->advance(lexer, false);
        lexer->result_symbol = COLON;
        s->colon_count++;
        return true;
    }
    if (lexer->eof(lexer)) {
        // fprintf(stderr, "EOF %d %d %c\n", s->colon_count, s->indent_count,
        // lexer->lookahead);
        if (s->colon_count) {
            s->colon_count--;
            lexer->result_symbol = COLON_END;
            return true;
        } else if (s->indent_count) {
            pop_indent(s);
            lexer->result_symbol = DEDENT;
            return true;
        }
        // } else {
        //     fprintf(stderr, "ELSE\n");
        // }
    }
    if (lexer->lookahead == ' ' || lexer->lookahead == '\t') {
        //     fprintf(stderr, "WS");
        lexer->advance(lexer, false);
        lexer->result_symbol = WHITESPACE;
        return true;
    }

    return false;
}
